\documentclass[a4paper]{article}

\usepackage[francais]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} 
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{xspace}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\usepackage{hyperref}

%% Tikz for picture drawing %%
\usepackage{tikz}
\usetikzlibrary{arrows}

\usepackage{xcolor,colortbl}
\usepackage{tabularx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}
\usepackage{subfloat}

\graphicspath{{figures/}}

\providecommand{\resume}[1]{\textbf{\textit{Résumé---#1}}}
\providecommand{\keywords}[1]{\textbf{\textit{Mots-clés---#1}}}

\newcommand{\TODO}{\textcolor{red}{\textbf{TODO}}}
\newcommand{\AB}{\emph{Alpha-Bêta}}

\newcommand\q[1]{%(question~#1)}
}
\newcommand\qs[1]{%(questions~#1)}
}
\newcommand\C[1]{\texttt{#1}}


\begin{document}


\title{ARCSYS2 Projet 2%
	\\ Communiquer et jouer en réseau}
\author{Simon Bihel, Florestan De Moor%
	 \\ ENS Rennes, 1ère année Département Informatique et Télécommunications}
\date{05 Avril 2016}

\maketitle

\resume{\TODO}\\

\keywords{\TODO}

\section*{Introduction}


Nous avons dans un projet précédent programmé un jeu des 7 couleurs en langage \texttt{C}, permettant à des joueurs humains et des joueurs artificiels de s'affronter. Nous avions pour cela implémenté différentes stratégies utilisables par des intelligences artificielles, et nous avions comparé leurs efficacités à travers un tournoi. \\

Mais tel que nous l'avons implémenté, si deux joueurs humains veulent jouer, ils doivent le faire sur la même machine. Si un tiers veut regarder la partie en tant que spectateur, il doit être physiquement présent devant l'écran de la machine sur laquelle tourne le jeu. Ceci est peu pratique, et ne permet pas une diffusion à large échelle des informations. \\

C'est pourquoi nous allons à travers ce projet modifier notre code source afin de le rendre compatible à une utilisation par un réseau. Le but est de faire tourner le jeu sur un serveur, et d'avoir des clients qui peuvent se connecter au serveur soit pour jouer, soit pour assister au match et le retransmettre. \\

Dans un premier temps, on s'intéresse à l'ajout de spectateurs, puis on fait jouer des joueurs à distance, et enfin, on modifie le serveur pour qu'il impose des contraintes équitables aux joueurs.

\section{Ajout de spectateurs}


Pour assister à un match en cours sur un serveur, on utilise la fonction \texttt{spectate()}. Cette fonction suit les différentes étapes suivantes :

%
\begin{itemize}
	\setlength\itemsep{1em}
	\item On ouvre une socket client, et on se connecte au serveur.
	\item On reçoit du serveur l'état actuel du jeu, la chaîne de caractère suit le format suivant :

		\bgroup
		\def\arraystretch{1.5}
		\begin{center}
		\begin{tabular}{|c|c|}
			\hline 
			\texttt{board\_size[40]} & \texttt{board[board\_size * board\_size]} \\ 
			\hline 
		\end{tabular} 	
		\end{center}
		\egroup
	
	\item On lance alors une partie qui démarre de la configuration reçue, en local. Le serveur envoie un coup sous la forme d'une chaîne de deux caractères. Le premier est la valeur du coup (donc une couleur), et le deuxième le symbole du joueur jouant ce coup. On met à jour le jeu local selon ces informations, et on affiche l'état courant du jeu. 
	\item Lorsque la partie est détectée en local comme étant terminée, on affiche le résultat final, et la socket client se ferme. \\

\end{itemize}
%


Côté serveur, le protocole est un peu plus compliqué, puisqu'on veut pouvoir gérer potentiellement plusieurs spectateurs, dont certains qui arrivent en cours de partie.
\TODO


\section{Joueurs à distance}

\subsection{Faire jouer des clients}



\subsection{Robustesse}

Il est possible que lors d'une partie, un joueur déconnecte soudainement ou bien que le serveur tombe en panne. Il faut ainsi ajouter des protocoles de protection pour savoir comment réagir dans ces cas là. \\

Si un spectateur déconnecte pendant la partie, le serveur ne doit pas être perturbé. Il peut cependant signaler par un affichage qu'il a remarqué une déconnexion d'un spectateur. \\

Si un joueur déconnecte \TODO \\

Du point de vue de la partie client, toutes les interactions avec le serveur (avec les fonctions \texttt{send} et \texttt{recv}) sont cachées derrière deux fonctions \texttt{server\_to\_client} et \texttt{client\_to\_server}. Ces fonctions vérifient la valeur de retour, et utilisent une boucle \texttt{while}. Un compteur est initialisé à \texttt{MAX\_SERVER\_MISS} et un temps d'attente à une seconde. Si on ne reçoit rien de valide du serveur (valeur de retour négative ou nulle), on décrémente le compteur, on attend, et on double la valeur du temps d'attente, avant d'entrer dans la prochaine itération de la boucle. Obtenir une réponse positive du serveur fait sortir de la boucle. Une fois le compteur nul, on sort de la boucle, et on quitte le programme en expliquant que le serveur semble être déconnecté. On effectue ainsi \texttt{MAX\_SERVER\_MISS} demandes au serveur, espacées d'un temps qui augmente exponentiellement. Concrètement, cela signifie que si l'on a pas réussi à avoir de connexion avec le serveur au bout de $2^{\texttt{MAX\_SERVER\_MISS}} - 1$ secondes, alors on le considère déconnecté. \\


\section{Contraintes imposées par le serveur}


\section*{Conclusion}

\TODO


\bibliographystyle{plain} 
\bibliography{report_arcsys2p2}

\end{document}